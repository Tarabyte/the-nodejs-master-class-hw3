/**
 * Simple templating
 */
const { dirname, join } = require('path')

const { readFile, writeFile } = require('./fs')

const isProd = process.env.NODE_ENV === 'production'

// template helpers
const helpers = {}

// global data
const globals = {}

// include helper factory
const includeFactory = templatePath => {
  const dir = dirname(templatePath)

  return (path, ...rest) => template(join(dir, path), ...rest)
}

// coroutine to resolve promises
const co = async (strings, ...values) => {
  values = await Promise.all(values)

  return Array.from(
    { length: strings.length + values.length },
    // intermix entries from strings and values
    (_, i) => (i % 2 ? values : strings)[(i / 2) | 0]
  ).join('')
}

// use proxy to coallesce null props access in dev mode
const prepareData = isProd
  ? data => data
  : (data, { tmpl, path = ['data'], fake = false } = {}) => {
      const propName = name => path.concat(name).join('.')

      const monitor = new Proxy(data, {
        /**
         * Only allow to set limited number of methods
         */
        set(target, key, value) {
          if (key === 'toString' || key === 'valueOf') {
            return Reflect.set(target, key, value)
          }
          throw new Error(`Attempt to set ${propName(key)} in template ${tmpl}`)
        },
        /**
         * Intercept getters to track nested values access
         */
        get(target, key) {
          // shortcut inherited properties
          if (
            typeof key === 'symbol' ||
            Reflect.has(Reflect.getPrototypeOf(target), key)
          ) {
            return Reflect.get(target, key)
          }

          const value = Reflect.get(target, key)
          const shouldFake = value == null

          // only wrap fakes and POJOs, built-ins are hard -_-
          const shouldWrap =
            shouldFake ||
            (typeof value === 'object' &&
              Reflect.getPrototypeOf(value) === Object.prototype)

          // wrap objects, null, and undefined values to support nested objects monitoring
          const finalValue = shouldWrap
            ? prepareData(shouldFake ? {} : value, {
                tmpl,
                path: path.concat(key),
                fake: shouldFake,
              })
            : value

          return finalValue
        },
      })

      if (fake) {
        // warn the user it trying to print fake
        monitor.toString = function() {
          console.warn(
            `${path.join('.')} was not provided to the template ${tmpl}`
          )
          return ''
        }
      }

      // always return original valuw
      monitor.valueOf = function() {
        return data
      }

      return monitor
    }

// compiled templates cache
const cache = isProd
  ? new Map()
  : {
      // null cache strategy
      has() {
        return false
      },
      get() {
        return undefined
      },
      set() {
        return this
      },
    }

// load and compile template
const compile = async path => {
  // check if compiled
  if (cache.has(path)) {
    return cache.get(path)
  }

  // read template string
  const body = (await readFile(path, 'utf-8')).trim()

  if (!body) {
    throw new Error(`Empty template ${path}`)
  }

  // compile the function
  const compiledPath = join(process.cwd(), `${path}.compiled.js`)

  // write generated file to disk to simplify debugging and such
  await writeFile(
    compiledPath,
    `/**
* Compiled template ${path}.
* This file is autogenerated do not modify.
*/
module.exports = (data, helpers, co) => co\`${body}\`
`
  )

  // use require to load generated content
  const fn = require(compiledPath)

  // make include relative to current template
  const include = includeFactory(path)

  // enhance data and helpers w/ globals
  const tmpl = (localData, localHelpers) =>
    fn(
      prepareData({ ...globals, ...localData }, { tmpl: path }),
      prepareData(
        { ...helpers, ...localHelpers, include },
        { tmpl: path, path: ['helpers'] }
      ),
      co
    )

  // save to avoid compilation step in future
  cache.set(path, tmpl)

  return tmpl
}

// compile and run template if data is passed
const template = async function(path, data, helpers) {
  const tmpl = await compile(path)

  // no data specified, only load template
  if (arguments.length === 1) {
    return tmpl
  }

  // data was specified, run the template
  return await tmpl(data, helpers)
}

template.compile = compile
template.globals = globals
template.helpers = helpers

module.exports = template
